#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TAG_SIZE sizeof(char *)

struct tigerstr {
  char *tag;
  int64_t length;
  /* This can be infinitely long when we start allocating strings. */
  unsigned char chars[1];
};

struct tigerarray {
  char *tag;
  int64_t length;
  int64_t data[1];
};

struct tigerrecord {
  char *tag;
  int64_t data[1];
};

/* Main function generated by compiler that will be linked with the runtime
 * library. */
extern int tigermain(int);

struct tigerstr consts[256];
/* Giving this a special tag as we do not want this to be garbage collected. */
struct tigerstr empty = {"!s", 0, ""};

int main() {
  for (int i = 0; i < 256; i++) {
    consts[i].tag = "!s";
    consts[i].length = 1;
    consts[i].chars[0] = i;
  }
  /* Call with static link */
  return tigermain(0);
}

void print(struct tigerstr *s) {
  unsigned char *p = s->chars;
  for (int i = 0; i < s->length; i++, p++)
    putchar(*p);
}

struct tigerarray *initArray(int64_t size, int64_t init, int64_t is_ptr) {
  /* First slot is the tag, followed by the size of the array and then
   * the data. */
  struct tigerarray *a = malloc(TAG_SIZE + (size + 1) * sizeof(int64_t));
  if (a == NULL) {
    fprintf(stderr, "Failed to allocate memory for `initArray`.\n");
    exit(1);
  }

  if (is_ptr) {
    a->tag = "ap";
  } else {

    a->tag = "an";
  }

  a->length = size;

  for (int i = 0; i < size; i++)
    a->data[i] = init;

  return a;
}

struct tigerrecord *allocRecord(char *tag) {
  int size = strlen(tag);
  struct tigerrecord *a = malloc(sizeof(char *) + size * sizeof(int64_t));

  if (a == NULL) {
    fprintf(stderr, "Failed to allocate memory for `allocRecord`.\n");
    exit(1);
  }

  a->tag = tag;

  for (int i = 0; i < size; i++)
    a->data[i] = 0;

  return a;
}

int not(int i) { return !i; }

/* String operations  */

int64_t ord(const struct tigerstr *s) {
  if (s->length == 0)
    return -1;
  else
    return s->chars[0];
}

struct tigerstr *chr(int64_t i) {
  if (i < 0 || i > 255) {
    printf("Called chr with out of range argument: %lld", i);
    exit(1);
  }

  return consts + i;
}

/* Number of characters in s. */
int64_t size(const struct tigerstr *s) { return s->length; }

/* Substring of string `s`, starting with character `first`, `n` characters
 * long. Characters are numbered starting at 0. */
struct tigerstr *substring(const struct tigerstr *s, int64_t first, int64_t n) {
  int64_t s_len = s->length;

  // Ensure `first` and `n` are within bounds.
  if (first < 0 || first + n > s->length) {
    fprintf(stderr, "substring([%lld],%lld,%lld) out of range\n", s->length,
            first, n);
    exit(1);
  }

  if (n == 1)
    return consts + s->chars[first];
  else {
    struct tigerstr *t = malloc(TAG_SIZE + sizeof(int64_t) + n);
    if (t == NULL) {
      fprintf(stderr, "Failed to allocate memory for `substring`.\n");
      exit(1);
    }

    /* This string needs to be handled by the GC, hence we give it the
     * 's' tag */
    t->tag = "s";
    t->length = n;

    for (int i = 0; i < n; i++)
      t->chars[i] = s->chars[first + i];
    return t;
  }
}

/* Concatenation of `s1` and `s2`. */
struct tigerstr *concat(struct tigerstr *a, struct tigerstr *b) {
  if (a->length == 0)
    return b;
  else if (b->length == 0)
    return a;
  else {
    int n = a->length + b->length;

    struct tigerstr *t = malloc(TAG_SIZE + sizeof(int) + n);
    if (t == NULL) {
      fprintf(stderr, "Failed to allocate memory for `substring`.\n");
      exit(1);
    }

    /* GC needs to handle this eventually, hence we give it the 's' tag */
    t->tag = "s";
    t->length = n;

    for (int i = 0; i < a->length; i++)
      t->chars[i] = a->chars[i];

    for (int i = 0; i < b->length; i++)
      t->chars[i + a->length] = b->chars[i];

    return t;
  }
}

void flush() { fflush(stdin); }

struct tigerstr *__wrap_getchar() {
  int i = getc(stdin);
  if (i == EOF)
    return &empty;
  else
    return consts + i;
}

/* Assert that pointer is non-null */
void assert_non_null(void *ptr) {
  if (ptr == NULL) {
    fprintf(stderr, "Null pointer encountered at runtime.\n");
    exit(1);
  }
}

extern int __real_strcmp(const char *str1, const char *str2);

int64_t __wrap_strcmp(const struct tigerstr *s1, const struct tigerstr *s2) {
  char *s1_copy = malloc(s1->length + 1);
  memcpy(s1_copy, s1->chars, s1->length);
  s1_copy[s1->length] = '\0';

  char *s2_copy = malloc(s2->length + 1);
  memcpy(s2_copy, s2->chars, s2->length);
  s2_copy[s2->length] = '\0';

  int res = __real_strcmp(s1_copy, s2_copy);

  free(s1_copy);
  free(s2_copy);

  return res;
}

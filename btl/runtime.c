#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct tigerstr {
  int64_t length;
  /* This can be infinitely long when we start allocating strings. */
  unsigned char chars[1];
};

/* Main function generated by compiler that will be linked with the runtime
 * library. */
extern int tigermain(int);

struct tigerstr consts[256];
struct tigerstr empty = {0, ""};

int main() {
  for (int i = 0; i < 256; i++) {
    consts[i].length = 1;
    consts[i].chars[0] = i;
  }
  /* Call with static link */
  return tigermain(0);
}

void print(struct tigerstr *s) {
  unsigned char *p = s->chars;
  for (int i = 0; i < s->length; i++, p++)
    putchar(*p);
}

int64_t *initArray(int64_t size, int64_t init) {
  int i;
  int64_t *a = (int64_t *)malloc(size * sizeof(int64_t));

  for (int i = 0; i < size; i++)
    a[i] = init;

  return a;
}

int *allocRecord(int size) {
  int i;
  int *p, *a;
  p = a = (int *)malloc(size);

  for (i = 0; i < size; i += sizeof(int))
    *p++ = 0;

  return a;
}

int not(int i) { return !i; }

/* String operations  */

int64_t ord(const struct tigerstr *s) {
  if (s->length == 0)
    return -1;
  else
    return s->chars[0];
}

struct tigerstr *chr(int64_t i) {
  if (i < 0 || i > 255) {
    printf("Called chr with out of range argument: %lld", i);
    exit(1);
  }

  return consts + i;
}

/* Number of characters in s. */
int64_t size(const struct tigerstr *s) { return s->length; }

/* Substring of string `s`, starting with character `first`, `n` characters
 * long. Characters are numbered starting at 0. */
struct tigerstr *substring(const struct tigerstr *s, int64_t first, int64_t n) {
  int substr_len;
  int64_t s_len = s->length;

  // Ensure `first` and `n` are within bounds.
  if (first < 0 || first + n > s->length) {
    fprintf(stderr, "substring([%lld],%lld,%lld) out of range\n", s->length, first, n);
    exit(1);
  }

  if (n == 1)
    return consts + s->chars[first];
  else {
    struct tigerstr *t = malloc(sizeof(int64_t) + n);
    if (t == NULL) {
      fprintf(stderr, "Failed to allocate memory for `substring`.\n");
      exit(1);
    }

    t->length = n;

    for (int i = 0; i < n; i++)
      t->chars[i] = s->chars[first + i];
    return t;
  }
}

/* Concatenation of `s1` and `s2`. */
struct tigerstr *concat(struct tigerstr *a, struct tigerstr *b) {
  if (a->length == 0)
    return b;
  else if (b->length == 0)
    return a;
  else {
    int n = a->length + b->length;

    struct tigerstr *t = malloc(sizeof(int) + n);
    if (t == NULL) {
      fprintf(stderr, "Failed to allocate memory for `substring`.\n");
      exit(1);
    }

    t->length = n;

    for (int i = 0; i < a->length; i++)
      t->chars[i] = a->chars[i];

    for (int i = 0; i < b->length; i++)
      t->chars[i + a->length] = b->chars[i];

    return t;
  }
}

void flush() { fflush(stdin); }

struct tigerstr *__wrap_getchar() {
  int i = getc(stdin);
  if (i == EOF)
    return &empty;
  else
    return consts + i;
}

/* Assert that pointer is non-null */
void assert_non_null(void *ptr) {
  if (ptr == NULL) {
    fprintf(stderr, "Null pointer encountered at runtime.\n");
    exit(1);
  }
}

extern int __real_strcmp(const char *str1, const char *str2);

int64_t __wrap_strcmp(const struct tigerstr *s1, const struct tigerstr *s2) {
  char *s1_copy = malloc(s1->length + 1);
  memcpy(s1_copy, s1->chars, s1->length);
  s1_copy[s1->length] = '\0';

  char *s2_copy = malloc(s2->length + 1);
  memcpy(s2_copy, s2->chars, s2->length);
  s2_copy[s2->length] = '\0';

  int res = __real_strcmp(s1_copy, s2_copy);

  free(s1_copy);
  free(s2_copy);

  return res;
}
